#!/usr/bin/env python3

import argparse
import os
import subprocess
import re
import sys
import random
import signal

maps = ["Barrier", "DenseForest", "Enclosure", "Hurdle", "LineOfFire", "MagicWood", "SparseForest", "shrine"]
lowerMaps = [m.lower() for m in maps]

parser = argparse.ArgumentParser(description='Run BattleCode Bots')
parser.add_argument("-m", "--map", help="Which map to use", choices=lowerMaps, default=maps[-1], type=str.lower)
parser.add_argument("-a", "--teamA", help="Team A")
parser.add_argument("-b", "--teamB", help="Team B")
parser.add_argument("--tournament", help="Play multiple games and rank the teams", action="store_true")
parser.add_argument("-q", "--quiet", help="Don't print bot logs", action="store_true")
parser.add_argument("--seed", help="Seed for the game or tournament", type=int)
args = parser.parse_args()

red = (201, 27, 0)
green = (0, 194, 0)
yellow = (199, 196, 0)
gray = (150, 150, 150)

colorFormat = "\x1b[38;2;{0[0]};{0[1]};{0[2]}m"
redStr = colorFormat.format(red)
greenStr = colorFormat.format(green)
yellowStr = colorFormat.format(yellow)
grayStr = colorFormat.format(gray)
reset = "\033[0m"
clearScreen = "\033[2J"
active_commands = []


def execute(cmd, quiet):
    popen = subprocess.Popen(cmd,
                             stdout=subprocess.PIPE,
                             stderr=subprocess.DEVNULL if quiet else None,
                             universal_newlines=False
                             )

    active_commands.append(popen)
    while True:
        b = popen.stdout.readline()
        if b == b"":
            break
        else:
            s = b.decode('utf-8')
            if not quiet:
                print(s, end="")
            yield s

    popen.stdout.close()
    return_code = popen.wait()
    active_commands.remove(popen)

    if return_code:
        raise subprocess.CalledProcessError(return_code, cmd)

    # return "\n".join(lines)


def updateSeed(seed):
    s = open("src/bot/Robot.java").read()
    s = re.sub("SEED = [\d]+", "SEED = " + str(seed), s)
    open("src/bot/Robot.java", "w").write(s)


def run(teamA, teamB, maps, quiet, seed):
    updateSeed(seed)
    gradleArgs = ["./gradlew", "run"]

    if teamA is not None:
        gradleArgs.append("-PteamAclasspath=" + os.path.join(os.getcwd(), "backups/" + teamA))

    if teamB is not None:
        gradleArgs.append("-PteamBclasspath=" + os.path.join(os.getcwd(), "backups/" + teamB))

    if maps is not None:
        gradleArgs.append("-Pmaps=" + ",".join(maps))

    winRegex = re.compile(r"bot \(([AB])\) wins \(round (\d+)\)")
    reasonRegex = re.compile(r"Reason: The winning team won ([^\n\.]+)")
    gen = execute(gradleArgs, quiet)
    for line in gen:
        win = winRegex.search(line)
        if win is not None:
            reason = reasonRegex.search(next(gen))

            winningTeam = win.group(1)
            round = int(win.group(2))
            reason = reason.group(1)
            yield (winningTeam, round, reason)


def printResult(result):
    team = result[0]
    round = result[1]
    reason = result[2]
    teamStr = (greenStr if team == "A" else redStr) + team + reset
    print(teamStr + " won at round " + str(round) + " " + reason)


# Make sure the seed is reset to 0 even if the user terminates the program
def sigint(signal, frame):
    updateSeed(0)
    for p in active_commands:
        p.terminate()

    sys.exit(0)


def run_tournament_part(teamA, teamB, switch, seed):
    if switch:
        teamA, teamB = teamB, teamA

    gen = run(teamA, teamB, maps, True, seed)

    for map in maps:
        mapStr = yellowStr + map.ljust(12) + reset + " " + ("B vs A" if switch else "A vs B") + ": "
        print(mapStr + grayStr + "..." + reset, end="")
        sys.stdout.flush()
        result = next(gen)

        if switch:
            result = ("B" if result[0] == "A" else "A", result[1], result[2])

        print("\r" + mapStr, end="")
        printResult(result)

        yield result[0] == "A"


signal.signal(signal.SIGINT, sigint)

startSeed = args.seed if args.seed is not None else 0
if args.tournament:
    teamAwins = 0
    totalCount = 0

    for seed in range(startSeed, startSeed + 5):
        # Run AvsB and BvsA in parallel
        g1 = run_tournament_part(args.teamA, args.teamB, False, seed)
        g2 = run_tournament_part(args.teamA, args.teamB, True, seed)
        for v in zip(g1, g2):
            for teamAwon in v:
                if teamAwon:
                    teamAwins += 1
                totalCount += 1

        print("Team A has won " + str((teamAwins / totalCount) * 100) + "% of the time (" +
              str(teamAwins) + " of " + str(totalCount) + ")")
        print("Continuing with new seed...")
        updateSeed(0)

else:
    actualMap = maps[lowerMaps.index(args.map.lower())]
    printResult(next(run(args.teamA, args.teamB, [actualMap], args.quiet, startSeed)))
